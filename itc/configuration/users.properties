# User Service configuration file

# Service ID, this is a random String used to identify a specific instance of the service
# like 83DZqvwbXzmtllVq, when ${COMMON_SERVICE_ID} is set, it means that the value will come from the environment variable COMMON_SERVICE_ID
# Every instances needs to use a different ID and the same ID should be used everytime this service is started.
# A default static value is existing in case of single instance deployment w/o environment variable set.
common.service.id=${COMMON_SERVICE_ID:83DZqvwbXzmtllVq}

# Intracom Service configuration.
# Defines how the service will broadcast messages to all the distributed instances of itself
# Medium can be db or mqtt, currently only db is implemented
users.intracom.medium=db

# ------------------------------------------------------
# User Registration configuration

# Defines if the user self registration is enabled or not
users.registration.self=${USERS_REGISTRATION_SELF:true}
# Defines is the registration requires a valid invite code
users.registration.with.invitecode=${USERS_REGISTRATION_WITH_INVITECODE:false}
# Size limitation for the user email - to limit injection stuff
users.registration.email.maxlength=${USERS_REGISTRATION_EMAIL_MAXLENGTH:128}
# Email Filter list, patterns in this list will be refused, regex, comma separated
users.registration.email.filters=${USERS_REGISTRATION_EMAIL_FILTER:}
# Registration link expiration delay in seconds
users.registration.link.expiration=${USERS_REGISTRATION_LINK_EXPIRATION:3600}
# Registration link sent by email
user.registration.link.byemail=${USER_REGISTRATION_LINK_BYEMAIL:true}
# Registration path, will be added on front baseUrl; the !0! will be replaced by registration secret. Can be in path also ?secret=!0!
user.registration.path=${USER_REGISTRATION_PATH:/registration/!0!/confirm}

# -----------------------------------------------------
# User Password lost - the !0! will be replaced by the lost password secret
user.lostpassword.path=${USER_LOSTPASSWORD_PATH:/lostpassword/!0!/confirm}


# -----------------------------------------
# User creation

# On user creation, account is automatically activated w/o administrator validation
users.pending.autovalidation=${USER_PENDING_AUTOVALIDATION:true}
# Is EULA acceptation required on user creation ( can be later / not blocking otherwise)
users.creation.need.eula=${USER_CREATION_NEEDEULA:false}
# Standard password expiration for users, 0 is never
users.password.expiration.days=${USER_PASSWORD_EXPIRATION_DAYS:0}
users.password.min.size=${USER_PASSWORD_MIN_SIZE:8}
users.password.min.uppercase=${USER_PASSWORD_MIN_UPPERCASE:0}
users.password.min.lowercase=${USER_PASSWORD_MIN_LOWERCASE:0}
users.password.min.numbers=${USER_PASSWORD_MIN_NUMBERS:0}
users.password.min.symbols=${USER_PASSWORD_MIN_SYMBOLS:0}
# String addition to the password like header=1234, footer=5678 so password will become 1234password5678
# this is to add a secret out of the database to hash the password
users.password.header=${USER_PASSWORD_HEADER:}
users.password.footer=${USER_PASSWORD_FOOTER:}

# Personal data encryption key expiration in days - after this duration, the required key for
# decryption will be destroyed. Only when user will log again, the key will be generated again.
# every login will renew the duration
users.data.privacy.expiration.days=${USER_DATA_PRIVACY_EXPIRATION_DAYS:730}

# Lost password reset link expiration delay in seconds
users.lostpassword.link.expiration_s=${USERS_LOSTPASSWORD_LINK_EXPIRATION_S:3600}

# -----------------------------------------
# User deletion

# user account is logically deleted but physically removed after the amount of time
# in hour. The value 0 means the account is immediately physically deleted.
users.deletion.purgatory.duration_h=$={USER_PURGATORY_DURATION_H:0}

# -----------------------------------------
# User cache (Read Only)

# Number of entries in the cache
users.cache.max.size=${USERS_CACHE_MAX_SIZE:1000}
# Time to live for the cache in seconds - 0 infinite
users.cache.expiration_s=${USERS_CACHE_EXPIRATION_S:0}
# Cache state log period
users.cache.log.period=${USERS_CACHE_LOG_PERIOD:PT24H}

# -----------------------------------------
# User session

# JWT user session expiration in seconds
users.session.timeout.sec=${USERS_SESSION_TIMEOUT_S:36000}
# JWT for renewal time extension in seconds to be added to the session expiration
users.session.renewal.extra.sec=${USERS_SESSION_RENEWAL_EXTRA_S:3600}
# API key expiration in seconds - 0 Unlimited
users.session.api.timeout.sec=${USERS_SESSION_API_TIMEOUT:0}
# JWT users session expiration in seconds to get the 2FA validation
user.session.2fa.timeout.sec=${USER_SESSION_2FA_TIMEOUT:600}
# JWT common session key (mixed with the user key for creating a session key) - 32 bytes
users.session.key=${USERS_SESSION_KEY:9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a}

# Security - Size limitation for the FailureCounter hashmap (preserve memory but reduce the number the security level)
users.session.security.hashmap.size=${USERS_SESSION_SECURITY_HASHMAP_SIZE:1000}
# Security - Number of failed attempts before blocking the user / ip during the block.period
users.session.security.max.login.failed=${USERS_SESSION_SECURITY_MAX_LOGIN_FAILED:30}
users.session.security.max.ip.failed=${USERS_SESSION_SECURITY_MAX_IP_FAILED:300}
# Security - Period of time in seconds to block the user / ip
users.session.security.block.period_s=${USERS_SESSION_SECURITY_BLOCK_PERIOD_SEC:3600}