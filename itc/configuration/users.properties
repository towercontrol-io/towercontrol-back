# User Service configuration file

# Service ID, this is a random String used to identify a specific instance of the service
# like 83DZqvwbXzmtllVq, when ${COMMON_SERVICE_ID} is set, it means that the value will come from the environment variable COMMON_SERVICE_ID
# Every instances needs to use a different ID and the same ID should be used everytime this service is started.
# A default static value is existing in case of single instance deployment w/o environment variable set.
common.service.id=${COMMON_SERVICE_ID:83DZqvwbXzmtllVq}

# Intracom Service configuration.
# Defines how the service will broadcast messages to all the distributed instances of itself
# Medium can be db or mqtt, currently only db is implemented
users.intracom.medium=db

# ------------------------------------------------------
# User Registration configuration

# Defines if the user self registration is enabled or not
users.registration.self=${USERS_REGISTRATION_SELF:true}
# Defines is the registration requires a valid invite code
users.registration.with.invitecode=${USERS_REGISTRATION_WITH_INVITECODE:false}
# Size limitation for the user email - to limit injection stuff
users.registration.email.maxlength=${USERS_REGISTRATION_EMAIL_MAXLENGTH:128}
# Email Filter list, patterns in this list will be refused, regex, comma separated
users.registration.email.filters=${USERS_REGISTRATION_EMAIL_FILTER:}
# Registration link expiration delay in seconds
users.registration.link.expiration=${USERS_REGISTRATION_LINK_EXPIRATION:3600}
# Registration link sent by email
users.registration.link.byemail=${USERS_REGISTRATION_LINK_BYEMAIL:true}
# Registration path, will be added on front baseUrl; the !0! will be replaced by registration secret. Can be in path /!0!/ or parameter ?secret=!0!
#  when the registration path is empty, the email will contain de registration code instead of a link
users.registration.path=${USERS_REGISTRATION_PATH:/front/public/register?verificationKey=!0!}

# -----------------------------------------------------
# User Password lost - the !0! will be replaced by the lost password secret
users.lostpassword.path=${USERS_LOSTPASSWORD_PATH:/front/public/password-change?verificationKey=!0!}

# -----------------------------------------
# Super admin auto creation (created only when the username and password are set)
users.superadmin.email=${USERS_SUPERADMIN_EMAIL:}
users.superadmin.password=${USERS_SUPERADMIN_PASSWORD:}

# -----------------------------------------
# User creation

# On user creation, account is automatically activated w/o administrator validation
users.pending.autovalidation=${USERS_PENDING_AUTOVALIDATION:true}
# Is EULA acceptation required on user creation ( can be later / not blocking otherwise)
users.creation.need.eula=${USERS_CREATION_NEEDEULA:false}
# Standard password expiration for users, 0 is never
users.password.expiration.days=${USERS_PASSWORD_EXPIRATION_DAYS:0}
users.password.min.size=${USERS_PASSWORD_MIN_SIZE:8}
users.password.min.uppercase=${USERS_PASSWORD_MIN_UPPERCASE:0}
users.password.min.lowercase=${USERS_PASSWORD_MIN_LOWERCASE:0}
users.password.min.numbers=${USERS_PASSWORD_MIN_NUMBERS:0}
users.password.min.symbols=${USERS_PASSWORD_MIN_SYMBOLS:0}
# String addition to the password like header=1234, footer=5678 so password will become 1234password5678
# this is to add a secret out of the database to hash the password
users.password.header=${USERS_PASSWORD_HEADER:}
users.password.footer=${USERS_PASSWORD_FOOTER:}

# Personal data encryption key expiration in days - after this duration, the required key for
# decryption will be destroyed. Only when user will log again, the key will be generated again.
# every login will renew the duration
users.data.privacy.expiration.days=${USERS_DATA_PRIVACY_EXPIRATION_DAYS:730}

# Lost password reset link expiration delay in seconds
users.lostpassword.link.expiration_s=${USERS_LOSTPASSWORD_LINK_EXPIRATION_S:3600}

# User default roles, list of ROLES separated by comma (ROLE_XXX_XXX,ROLE_XXXX_YYY)
#  Do not include ROLE_PENDING_USER, ROLE_REGISTERED_USER specially used in registration process
users.default.roles=${USERS_DEFAULT_ROLES:}

# API Key authorized roles, list of ROLES separated by comma (ROLE_XXX_XXX,ROLE_XXXX_YYY)
#  Do not include non affectable role specially used in registration process
users.apikey.authorized.roles=${USERS_APIKEY_AUTHORIZED_ROLES:}

# -----------------------------------------
# User deletion

# user account is logically deleted but physically removed after the amount of time
# in hour. The value 0 means the account is immediately physically deleted.
users.deletion.purgatory.duration_h=${USERS_PURGATORY_DURATION_H:0}

# -----------------------------------------
# User cache (Read Only)

# Number of entries in the cache
users.cache.max.size=${USERS_CACHE_MAX_SIZE:1000}
# Time to live for the cache in seconds - 0 infinite
users.cache.expiration_s=${USERS_CACHE_EXPIRATION_S:0}
# Cache state log period
users.cache.log.period=${USERS_CACHE_LOG_PERIOD:PT24H}

# Number of entries in the apikey cache
users.cache.apikey.max.size=${USERS_CACHE_MAX_SIZE:1000}
# Time to live for the cache in seconds - 0 infinite
users.cache.apikey.expiration_s=${USERS_CACHE_EXPIRATION_S:0}
# Cache state log period
users.cache.apikey.log.period=${USERS_CACHE_LOG_PERIOD:PT24H}


# -----------------------------------------
# User session

# JWT user session expiration in seconds
users.session.timeout.sec=${USERS_SESSION_TIMEOUT_S:36000}
# JWT for renewal time extension in seconds to be added to the session expiration
users.session.renewal.extra.sec=${USERS_SESSION_RENEWAL_EXTRA_S:3600}
# API key expiration in seconds - 0 Unlimited
users.session.api.timeout.sec=${USERS_SESSION_API_TIMEOUT:0}
# JWT users session expiration in seconds to get the 2FA validation
users.session.2fa.timeout.sec=${USERS_SESSION_2FA_TIMEOUT:600}
# JWT common session key (mixed with the user key for creating a session key) - 32 bytes
users.session.key=${USERS_SESSION_KEY:9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a}

# Security - Size limitation for the FailureCounter hashmap (preserve memory but reduce the number the security level)
users.session.security.hashmap.size=${USERS_SESSION_SECURITY_HASHMAP_SIZE:1000}
# Security - Number of failed attempts before blocking the user / ip during the block.period
users.session.security.max.login.failed=${USERS_SESSION_SECURITY_MAX_LOGIN_FAILED:30}
users.session.security.max.ip.failed=${USERS_SESSION_SECURITY_MAX_IP_FAILED:300}
# Security - Period of time in seconds to block the user / ip
users.session.security.block.period_s=${USERS_SESSION_SECURITY_BLOCK_PERIOD_SEC:3600}